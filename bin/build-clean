#!/usr/bin/env ruby

require 'thor'

require_relative '../lib/builderator/config'
require_relative '../lib/builderator/control/cleaner'

module Builderator
  module Tasks
    ##
    # Tasks to identify and remove unused EC2 resources
    ##
    class Cleaner < Thor
      class_option :region,
                   :type => :string,
                   :aliases => :r,
                   :desc => 'AWS Region in which to perform tasks'
      class_option :commit,
                   :type => :boolean,
                   :default => false,
                   :desc => 'Perform mutating API calls to cleanup resources'
      class_option :filter,
                   :type => :array,
                   :aliases => :f,
                   :desc => 'Key/value pairs to filter resources (--filter name foo owner_id 123456789)'
      class_option :force,
                   :type => :boolean,
                   :default => false,
                   :desc => 'Disable safety restrictions, including resource limits'

      def initialize(*_)
        super

        ## Convert array of filter key-values to a hash
        options['filters'] = Hash[*options['filter']] if options['filter'].is_a?(Array)

        Config.argv(:cleaner => options) ## Load command flags
        Config.load(File.join(ENV['HOME'], '.builderator/Buildfile'))
        Config.load(Util.relative_path('Buildfile').to_s)

        Config.recompile

        puts Config.cleaner.to_hash

        unless Config.cleaner.commit
          say_status 'dry-run', 'This is a dry-run.'
          return
        end

        say_status :grouping, "Group by #{Config.cleaner.group_by}" if Config.cleaner.group_by

        say_status :commit, 'This is not a dry-run. Press CTL-C to stop! '\
                            '(continuing in 5 seconds)', :red
        sleep(5) ## Give $USER a few seconds to stop

        return unless Config.cleaner.force

        say_status :force, 'Limits will be ignored. Press CTL-C to stop! '\
                           '(continuing in 5 seconds)', :red
        sleep(5) ## Give $USER a few seconds to stop
      end

      desc 'configs', 'Delete unused launch configurations'
      def configs
        Control::Cleaner.configs!(&method(:say_status))
      end

      desc 'images', 'Deregister unused images'
      option 'group-by',
             :type => :array,
             :desc => 'Tags/properties to group images by for pruning'
      option 'sort-by',
             :type => :string,
             :default => 'creation_date',
             :desc => 'Tag/property to sort grouped images on'
      option :keep,
             :type => :numeric,
             :default => 5,
             :desc => 'Number of images in each group to keep'
      def images
        Control::Cleaner.images!(&method(:say_status))
      end

      desc 'snapshots', 'Delete unused snapshots'
      def snapshots
        Control::Cleaner.snapshots!(&method(:say_status))
      end

      desc 'volumes', 'Delete unused volumes'
      def volumes
        Control::Cleaner.volumes!(&method(:say_status))
      end

      desc 'all', 'Cleaner volumes, launch configs, images, and snapshots in order'
      option 'group-by',
             :type => :array,
             :desc => 'Tags/properties to group images by for pruning'
      option 'sort-by',
             :type => :string,
             :default => 'creation_date',
             :desc => 'Tag/property to sort grouped images on'
      option :keep,
             :type => :numeric,
             :default => 5,
             :desc => 'Number of images in each group to keep'
      def all
        volumes
        configs
        images
        snapshots

        ## TODO Print resource counts here.
        return if Control::Cleaner.exceptions.empty?

        say_status :fail, 'Not all tasks completed successfully. The following '\
          'exceptions occured:', :red
        Control::Cleaner.exceptions.each do |e|
          say_status(*e.status)
        end

        ## Mark the Jenkins job as fail if there were errors.
        exit(1)
      end
    end
  end
end

Builderator::Tasks::Cleaner.start(ARGV)
